javascript， 模块化系统是构建大型项目基础，模块化不影响全局代码命名空间，功能分离，代码服用，依赖管理
两大主流模块系统 CommonJS （CJS）和 ECMAScript Module（ESM）

NodeJs 环境 原生支持 CommonJs ，后期也引入了 ESM 模块系统
浏览器 CJS ESM 同时支持

 CommonJs :CJS ,使用require() 方法导入模块，module.exports 或者 exports 定义 .js 文件为模块并导出
 同步加载代码，意味着代码加载完后会立即执行，

## 问题：
在服务器环境中，同步加载代码没有问题，文件都在服务器本地，但是在浏览器中，文件资源是通过网络http请求获取的，
基于网络不稳定因素，同步加载可能就会存在性能问题，浏览器单线程，加载资源会阻塞 浏览器事件循环，直到脚本完全下载和解析。

 ES Module ：ESM 现代浏览器官方标准模块系统 有条件的异步执行，异步加载特性和模块解析逻辑
使用 import 导入模块， export 导出模块

ESM 是静态的 不能在运行时动态地加载或创建模块文件 

## 理解两个概念 静态模块，动态模块
静态：意味着模块之间的依赖关系在代码编写时就已经确定，并且在整个应用程序的生命周期都不会改变，静态特性有助于构建工具
（webpack 和 Rollup）进行高效代码优化。在不执行代码的情况下分析出模块之间的依赖关系，提高代码可维护性和可预测性。
ESM 不支持动态地 require 一个模块

CJS 在代码运行时，可以使用变量来确定 加载哪个模块，模块之间依赖关系就不明确，不稳定，比较大的灵活性，
import {ref} from vue
引入模块，不是声明变量，import是静态语句， 不能使用变量或表达式来动态确定要加载的模块
意味着 我们不能在代码程序运行时 来创建新的模块文件并立即加载它们，所有的模块文件都必须在构建或部署应用之前就已经存在了
这就是静态模块，动态模块 在程序运行时 也可以创建，加载并执行。

但是 ESM 有个方法 import() 能动态的异步加载模块，某种程度类似 CJS 的动态加载模块，仍然有限制，本质上通过创建
一个新的子模块来实现动态加载

在JavaScript和Node.js中，当我们谈到“静态”和“动态”时，我们通常指的是代码的某些方面是在编写时确定的（静态），还是在运行时确定的（动态）。这里有一些关键概念，可以帮助你更好地理解这两者的区别：

### 静态的（Static）

1. **静态类型检查**：在一些编程语言（如TypeScript，它是JavaScript的超集）中，你可以在编写代码时指定变量的类型。类型检查器会在编译时检查这些类型，以确保你不会做出例如将一个字符串赋值给一个期望数字的变量这样的错误。虽然原生的JavaScript不执行静态类型检查，但你可以通过工具（如ESLint）或使用TypeScript来增加这个功能。

2. **静态代码分析**：在不执行代码的情况下对其进行分析，以发现潜在的问题或优化机会。例如，静态分析工具可以找出未使用的变量、未结束的字符串或潜在的代码重构机会。

3. **静态导入和导出**：在ESM（ECMAScript模块）中，`import`和`export`语句是静态的，这意味着它们必须在代码的顶级作用域中使用，不能放在条件语句、函数或循环中。导入和导出的模块及其成员在编译时是已知的。

### 动态的（Dynamic）

1. **动态类型**：JavaScript是一种动态类型的语言，这意味着你不必在声明变量时指定它的类型。变量的类型是根据赋值给它的值在运行时动态确定的。

2. **动态代码执行**：JavaScript允许你在运行时构建和执行代码字符串。例如，使用`eval()`函数或`new Function()`构造函数可以执行动态生成的代码。这通常被认为是一种不好的做法，因为它会降低代码的可读性，增加安全风险，并使得代码更难以分析和优化。

3. **动态加载**：在JavaScript中，你可以使用`import()`函数来动态地加载模块。这是一个返回Promise的函数，它允许你在运行时按需加载代码，这在创建大型应用程序


## CJS与 ESM 兼容性问题
在 Node.js 中，ESM 的异步特性与现有的大量 CommonJS 模块存在不兼容问题。

当前在 Node.js 中启用 ESM 的方法要复杂一些，因为代表性的 .js 文件扩展名默认与 CommonJS 模块关联。
为了解决此问题，Node.js 允许使用 .mjs 文件扩展名或在 package.json 中明确指定 "type": "module" 属性来表示 ESM 模块。

由于 ESM 是在 Node.js 中提供支持的，所以我们可以 import cjs，但不可能 require(esm)。

ESM 本身并不是真正设计成无条件异步的。而是设计成只在条件下异步 - 只有当代码中包含顶级 await 时才会异步。

require(esm) 仅支持显式标记为 ESM 的 ESM - 通过 .mjs 扩展名或者对 .js 扩展名的 "type“: "module" 包字段。
当.js 文件中包含了 ESM 语法（import、export）pack.json中没有"type": "module" 字段时，回退到
ESM 加载。用户通常应该避免掉该行为 ，ESM 语法检测会产生开销。
在package.json里 配置 "type":module， 节省 Node 检查模块类型的开销


tree-shaking（摇树优化，移除未使用的代码）
